## 在线高精算法论文阅读笔记

[TOC]



### HDMapNet: An Online HD Map Construction and Evaluation Framework

1. 参考文档：
   + 论文：https://www.cnblogs.com/xiaoliu-ya/p/16553462.html
   + 代码：https://github.com/Tsinghua-MARS-Lab/HDMapNet/tree/main

2. 参考笔记的补充：

   + 关于语义预测：很普通的FCN加上交叉损失熵函数；
   + 关于实例预测：
     + 损失函数详见Lanenet。有点疑惑这种依赖参数的表示方式会不会鲁棒性比较差？
     + $C(C-1)$是组合数公式去掉了系数；
   + 关于方向预测：
     + 理解为转换为一个二分类问题，这里其实可以参考环形标签（旋转目标检测）论文来改进方向；
     + 地图上的大多数像素都不位于车道上，这意味着它们没有方向。 这些像素的方向向量是零向量，。作者不在训练期间对这些像素进行反向传播，但是这在推理期间如何处理呢？如何实现呢？
   + 关于向量化： 在推断过程中，首先使用基于密度的带噪声应用空间聚类 (DBSCAN) 对实例嵌入进行聚类。然后使用非极大值抑制来减少冗余。最后，利用预测的方向贪婪地连接像素，得到向量表示。

3. 代码原理补充：

   + 关于批量标准化图像：

     正向标准化的方程为：$ z = (x - \text{mean}) / \sigma $，因此有：
     $$
     \begin{aligned}
     x &= z * \sigma + \text{mean} \\
       &= (z + \text{mean}/\sigma) * \sigma \\
       &= \left(z - \left(-\text{mean}/\sigma\right)\right) / (1/\sigma) \\
       &= (z - \text{mean}^{-1} )/ \sigma^{-1} \\
      \end{aligned}
     $$
     这解释了代码：

     ```python
     class NormalizeInverse(torchvision.transforms.Normalize):
         #  https://discuss.pytorch.org/t/simple-way-to-inverse-transform-normalization/4821/8
         def __init__(self, mean, std):
             mean = torch.as_tensor(mean)
             std = torch.as_tensor(std)
             std_inv = 1 / (std + 1e-7)
             mean_inv = -mean * std_inv
             # super()：通常在子类中使用，用于在子类中调用父类的方法或属性
             super().__init__(mean=mean_inv, std=std_inv)
     
         # __call__：可以使得方法变成可被调用对象
         def __call__(self, tensor):
             return super().__call__(tensor.clone())
     ```


